// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storage

import (
	"context"
	messagecollector "github.com/diwise/iot-events/internal/pkg/msgcollector"
	"sync"
)

// Ensure, that StorageMock does implement Storage.
// If this is not the case, regenerate this file with moq.
var _ Storage = &StorageMock{}

// StorageMock is a mock implementation of Storage.
//
//	func TestSomethingThatUsesStorage(t *testing.T) {
//
//		// make and configure a mocked Storage
//		mockedStorage := &StorageMock{
//			FetchFunc: func(ctx context.Context, deviceID string, q messagecollector.QueryParams, tenants []string) (map[string][]messagecollector.Value, error) {
//				panic("mock out the Fetch method")
//			},
//			FetchIDOnlyFunc: func(ctx context.Context, deviceID string, tenants []string) ([]messagecollector.Value, error) {
//				panic("mock out the FetchIDOnly method")
//			},
//			FetchLatestFunc: func(ctx context.Context, deviceID string, tenants []string) ([]messagecollector.Value, error) {
//				panic("mock out the FetchLatest method")
//			},
//			QueryFunc: func(ctx context.Context, q messagecollector.QueryParams, tenants []string) messagecollector.QueryResult {
//				panic("mock out the Query method")
//			},
//			QueryDeviceFunc: func(ctx context.Context, deviceID string, tenants []string) messagecollector.QueryResult {
//				panic("mock out the QueryDevice method")
//			},
//			QueryObjectFunc: func(ctx context.Context, deviceID string, urn string, tenants []string) messagecollector.QueryResult {
//				panic("mock out the QueryObject method")
//			},
//			SaveFunc: func(ctx context.Context, m messagecollector.Measurement) error {
//				panic("mock out the Save method")
//			},
//			SaveManyFunc: func(ctx context.Context, m []messagecollector.Measurement) error {
//				panic("mock out the SaveMany method")
//			},
//		}
//
//		// use mockedStorage in code that requires Storage
//		// and then make assertions.
//
//	}
type StorageMock struct {
	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context, deviceID string, q messagecollector.QueryParams, tenants []string) (map[string][]messagecollector.Value, error)

	// FetchIDOnlyFunc mocks the FetchIDOnly method.
	FetchIDOnlyFunc func(ctx context.Context, deviceID string, tenants []string) ([]messagecollector.Value, error)

	// FetchLatestFunc mocks the FetchLatest method.
	FetchLatestFunc func(ctx context.Context, deviceID string, tenants []string) ([]messagecollector.Value, error)

	// QueryFunc mocks the Query method.
	QueryFunc func(ctx context.Context, q messagecollector.QueryParams, tenants []string) messagecollector.QueryResult

	// QueryDeviceFunc mocks the QueryDevice method.
	QueryDeviceFunc func(ctx context.Context, deviceID string, tenants []string) messagecollector.QueryResult

	// QueryObjectFunc mocks the QueryObject method.
	QueryObjectFunc func(ctx context.Context, deviceID string, urn string, tenants []string) messagecollector.QueryResult

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, m messagecollector.Measurement) error

	// SaveManyFunc mocks the SaveMany method.
	SaveManyFunc func(ctx context.Context, m []messagecollector.Measurement) error

	// calls tracks calls to the methods.
	calls struct {
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Q is the q argument value.
			Q messagecollector.QueryParams
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// FetchIDOnly holds details about calls to the FetchIDOnly method.
		FetchIDOnly []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// FetchLatest holds details about calls to the FetchLatest method.
		FetchLatest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// Query holds details about calls to the Query method.
		Query []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q messagecollector.QueryParams
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// QueryDevice holds details about calls to the QueryDevice method.
		QueryDevice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// QueryObject holds details about calls to the QueryObject method.
		QueryObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Urn is the urn argument value.
			Urn string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// M is the m argument value.
			M messagecollector.Measurement
		}
		// SaveMany holds details about calls to the SaveMany method.
		SaveMany []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// M is the m argument value.
			M []messagecollector.Measurement
		}
	}
	lockFetch       sync.RWMutex
	lockFetchIDOnly sync.RWMutex
	lockFetchLatest sync.RWMutex
	lockQuery       sync.RWMutex
	lockQueryDevice sync.RWMutex
	lockQueryObject sync.RWMutex
	lockSave        sync.RWMutex
	lockSaveMany    sync.RWMutex
}

// Fetch calls FetchFunc.
func (mock *StorageMock) Fetch(ctx context.Context, deviceID string, q messagecollector.QueryParams, tenants []string) (map[string][]messagecollector.Value, error) {
	if mock.FetchFunc == nil {
		panic("StorageMock.FetchFunc: method is nil but Storage.Fetch was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Q        messagecollector.QueryParams
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Q:        q,
		Tenants:  tenants,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx, deviceID, q, tenants)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//
//	len(mockedStorage.FetchCalls())
func (mock *StorageMock) FetchCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Q        messagecollector.QueryParams
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Q        messagecollector.QueryParams
		Tenants  []string
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// FetchIDOnly calls FetchIDOnlyFunc.
func (mock *StorageMock) FetchIDOnly(ctx context.Context, deviceID string, tenants []string) ([]messagecollector.Value, error) {
	if mock.FetchIDOnlyFunc == nil {
		panic("StorageMock.FetchIDOnlyFunc: method is nil but Storage.FetchIDOnly was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Tenants:  tenants,
	}
	mock.lockFetchIDOnly.Lock()
	mock.calls.FetchIDOnly = append(mock.calls.FetchIDOnly, callInfo)
	mock.lockFetchIDOnly.Unlock()
	return mock.FetchIDOnlyFunc(ctx, deviceID, tenants)
}

// FetchIDOnlyCalls gets all the calls that were made to FetchIDOnly.
// Check the length with:
//
//	len(mockedStorage.FetchIDOnlyCalls())
func (mock *StorageMock) FetchIDOnlyCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}
	mock.lockFetchIDOnly.RLock()
	calls = mock.calls.FetchIDOnly
	mock.lockFetchIDOnly.RUnlock()
	return calls
}

// FetchLatest calls FetchLatestFunc.
func (mock *StorageMock) FetchLatest(ctx context.Context, deviceID string, tenants []string) ([]messagecollector.Value, error) {
	if mock.FetchLatestFunc == nil {
		panic("StorageMock.FetchLatestFunc: method is nil but Storage.FetchLatest was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Tenants:  tenants,
	}
	mock.lockFetchLatest.Lock()
	mock.calls.FetchLatest = append(mock.calls.FetchLatest, callInfo)
	mock.lockFetchLatest.Unlock()
	return mock.FetchLatestFunc(ctx, deviceID, tenants)
}

// FetchLatestCalls gets all the calls that were made to FetchLatest.
// Check the length with:
//
//	len(mockedStorage.FetchLatestCalls())
func (mock *StorageMock) FetchLatestCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}
	mock.lockFetchLatest.RLock()
	calls = mock.calls.FetchLatest
	mock.lockFetchLatest.RUnlock()
	return calls
}

// Query calls QueryFunc.
func (mock *StorageMock) Query(ctx context.Context, q messagecollector.QueryParams, tenants []string) messagecollector.QueryResult {
	if mock.QueryFunc == nil {
		panic("StorageMock.QueryFunc: method is nil but Storage.Query was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Q       messagecollector.QueryParams
		Tenants []string
	}{
		Ctx:     ctx,
		Q:       q,
		Tenants: tenants,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryFunc(ctx, q, tenants)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedStorage.QueryCalls())
func (mock *StorageMock) QueryCalls() []struct {
	Ctx     context.Context
	Q       messagecollector.QueryParams
	Tenants []string
} {
	var calls []struct {
		Ctx     context.Context
		Q       messagecollector.QueryParams
		Tenants []string
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// QueryDevice calls QueryDeviceFunc.
func (mock *StorageMock) QueryDevice(ctx context.Context, deviceID string, tenants []string) messagecollector.QueryResult {
	if mock.QueryDeviceFunc == nil {
		panic("StorageMock.QueryDeviceFunc: method is nil but Storage.QueryDevice was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Tenants:  tenants,
	}
	mock.lockQueryDevice.Lock()
	mock.calls.QueryDevice = append(mock.calls.QueryDevice, callInfo)
	mock.lockQueryDevice.Unlock()
	return mock.QueryDeviceFunc(ctx, deviceID, tenants)
}

// QueryDeviceCalls gets all the calls that were made to QueryDevice.
// Check the length with:
//
//	len(mockedStorage.QueryDeviceCalls())
func (mock *StorageMock) QueryDeviceCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}
	mock.lockQueryDevice.RLock()
	calls = mock.calls.QueryDevice
	mock.lockQueryDevice.RUnlock()
	return calls
}

// QueryObject calls QueryObjectFunc.
func (mock *StorageMock) QueryObject(ctx context.Context, deviceID string, urn string, tenants []string) messagecollector.QueryResult {
	if mock.QueryObjectFunc == nil {
		panic("StorageMock.QueryObjectFunc: method is nil but Storage.QueryObject was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Urn      string
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Urn:      urn,
		Tenants:  tenants,
	}
	mock.lockQueryObject.Lock()
	mock.calls.QueryObject = append(mock.calls.QueryObject, callInfo)
	mock.lockQueryObject.Unlock()
	return mock.QueryObjectFunc(ctx, deviceID, urn, tenants)
}

// QueryObjectCalls gets all the calls that were made to QueryObject.
// Check the length with:
//
//	len(mockedStorage.QueryObjectCalls())
func (mock *StorageMock) QueryObjectCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Urn      string
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Urn      string
		Tenants  []string
	}
	mock.lockQueryObject.RLock()
	calls = mock.calls.QueryObject
	mock.lockQueryObject.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *StorageMock) Save(ctx context.Context, m messagecollector.Measurement) error {
	if mock.SaveFunc == nil {
		panic("StorageMock.SaveFunc: method is nil but Storage.Save was just called")
	}
	callInfo := struct {
		Ctx context.Context
		M   messagecollector.Measurement
	}{
		Ctx: ctx,
		M:   m,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, m)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedStorage.SaveCalls())
func (mock *StorageMock) SaveCalls() []struct {
	Ctx context.Context
	M   messagecollector.Measurement
} {
	var calls []struct {
		Ctx context.Context
		M   messagecollector.Measurement
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// SaveMany calls SaveManyFunc.
func (mock *StorageMock) SaveMany(ctx context.Context, m []messagecollector.Measurement) error {
	if mock.SaveManyFunc == nil {
		panic("StorageMock.SaveManyFunc: method is nil but Storage.SaveMany was just called")
	}
	callInfo := struct {
		Ctx context.Context
		M   []messagecollector.Measurement
	}{
		Ctx: ctx,
		M:   m,
	}
	mock.lockSaveMany.Lock()
	mock.calls.SaveMany = append(mock.calls.SaveMany, callInfo)
	mock.lockSaveMany.Unlock()
	return mock.SaveManyFunc(ctx, m)
}

// SaveManyCalls gets all the calls that were made to SaveMany.
// Check the length with:
//
//	len(mockedStorage.SaveManyCalls())
func (mock *StorageMock) SaveManyCalls() []struct {
	Ctx context.Context
	M   []messagecollector.Measurement
} {
	var calls []struct {
		Ctx context.Context
		M   []messagecollector.Measurement
	}
	mock.lockSaveMany.RLock()
	calls = mock.calls.SaveMany
	mock.lockSaveMany.RUnlock()
	return calls
}
