// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package storage

import (
	"context"
	"sync"

	collector "github.com/diwise/iot-events/internal/pkg/measurements"
)

// Ensure, that StorageMock does implement Storage.
// If this is not the case, regenerate this file with moq.
var _ Storage = &StorageMock{}

// StorageMock is a mock implementation of Storage.
//
//	func TestSomethingThatUsesStorage(t *testing.T) {
//
//		// make and configure a mocked Storage
//		mockedStorage := &StorageMock{
//			FetchFunc: func(ctx context.Context, deviceID string, q collector.QueryParams, tenants []string) (map[string][]collector.Value, error) {
//				panic("mock out the Fetch method")
//			},
//			FetchLatestFunc: func(ctx context.Context, deviceID string, tenants []string) ([]collector.Value, error) {
//				panic("mock out the FetchLatest method")
//			},
//			QueryFunc: func(ctx context.Context, q collector.QueryParams, tenants []string) collector.QueryResult {
//				panic("mock out the Query method")
//			},
//			Query2Func: func(ctx context.Context, q collector.QueryParams, tenants []string) collector.QueryResult {
//				panic("mock out the Query2 method")
//			},
//			QueryDeviceFunc: func(ctx context.Context, deviceID string, tenants []string) collector.QueryResult {
//				panic("mock out the QueryDevice method")
//			},
//			QueryObjectFunc: func(ctx context.Context, deviceID string, urn string, tenants []string) collector.QueryResult {
//				panic("mock out the QueryObject method")
//			},
//			SaveFunc: func(ctx context.Context, m collector.Measurement) error {
//				panic("mock out the Save method")
//			},
//			SaveManyFunc: func(ctx context.Context, m []collector.Measurement) error {
//				panic("mock out the SaveMany method")
//			},
//			SeedMetadataFunc: func(ctx context.Context, metadata []collector.Metadata) error {
//				panic("mock out the SeedMetadata method")
//			},
//		}
//
//		// use mockedStorage in code that requires Storage
//		// and then make assertions.
//
//	}
type StorageMock struct {
	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context, deviceID string, q collector.QueryParams, tenants []string) (map[string][]collector.Value, error)

	// FetchLatestFunc mocks the FetchLatest method.
	FetchLatestFunc func(ctx context.Context, deviceID string, tenants []string) ([]collector.Value, error)

	// QueryFunc mocks the Query method.
	QueryFunc func(ctx context.Context, q collector.QueryParams, tenants []string) collector.QueryResult

	// Query2Func mocks the Query2 method.
	Query2Func func(ctx context.Context, q collector.QueryParams, tenants []string) collector.QueryResult

	// QueryDeviceFunc mocks the QueryDevice method.
	QueryDeviceFunc func(ctx context.Context, deviceID string, tenants []string) collector.QueryResult

	// QueryObjectFunc mocks the QueryObject method.
	QueryObjectFunc func(ctx context.Context, deviceID string, urn string, tenants []string) collector.QueryResult

	// SaveFunc mocks the Save method.
	SaveFunc func(ctx context.Context, m collector.Measurement) error

	// SaveManyFunc mocks the SaveMany method.
	SaveManyFunc func(ctx context.Context, m []collector.Measurement) error

	// SeedMetadataFunc mocks the SeedMetadata method.
	SeedMetadataFunc func(ctx context.Context, metadata []collector.Metadata) error

	// calls tracks calls to the methods.
	calls struct {
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Q is the q argument value.
			Q collector.QueryParams
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// FetchLatest holds details about calls to the FetchLatest method.
		FetchLatest []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// Query holds details about calls to the Query method.
		Query []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q collector.QueryParams
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// Query2 holds details about calls to the Query2 method.
		Query2 []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Q is the q argument value.
			Q collector.QueryParams
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// QueryDevice holds details about calls to the QueryDevice method.
		QueryDevice []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// QueryObject holds details about calls to the QueryObject method.
		QueryObject []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// DeviceID is the deviceID argument value.
			DeviceID string
			// Urn is the urn argument value.
			Urn string
			// Tenants is the tenants argument value.
			Tenants []string
		}
		// Save holds details about calls to the Save method.
		Save []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// M is the m argument value.
			M collector.Measurement
		}
		// SaveMany holds details about calls to the SaveMany method.
		SaveMany []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// M is the m argument value.
			M []collector.Measurement
		}
		// SeedMetadata holds details about calls to the SeedMetadata method.
		SeedMetadata []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Metadata is the metadata argument value.
			Metadata []collector.Metadata
		}
	}
	lockFetch        sync.RWMutex
	lockFetchLatest  sync.RWMutex
	lockQuery        sync.RWMutex
	lockQuery2       sync.RWMutex
	lockQueryDevice  sync.RWMutex
	lockQueryObject  sync.RWMutex
	lockSave         sync.RWMutex
	lockSaveMany     sync.RWMutex
	lockSeedMetadata sync.RWMutex
}

// Fetch calls FetchFunc.
func (mock *StorageMock) Fetch(ctx context.Context, deviceID string, q collector.QueryParams, tenants []string) (map[string][]collector.Value, error) {
	if mock.FetchFunc == nil {
		panic("StorageMock.FetchFunc: method is nil but Storage.Fetch was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Q        collector.QueryParams
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Q:        q,
		Tenants:  tenants,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx, deviceID, q, tenants)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//
//	len(mockedStorage.FetchCalls())
func (mock *StorageMock) FetchCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Q        collector.QueryParams
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Q        collector.QueryParams
		Tenants  []string
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// FetchLatest calls FetchLatestFunc.
func (mock *StorageMock) FetchLatest(ctx context.Context, deviceID string, tenants []string) ([]collector.Value, error) {
	if mock.FetchLatestFunc == nil {
		panic("StorageMock.FetchLatestFunc: method is nil but Storage.FetchLatest was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Tenants:  tenants,
	}
	mock.lockFetchLatest.Lock()
	mock.calls.FetchLatest = append(mock.calls.FetchLatest, callInfo)
	mock.lockFetchLatest.Unlock()
	return mock.FetchLatestFunc(ctx, deviceID, tenants)
}

// FetchLatestCalls gets all the calls that were made to FetchLatest.
// Check the length with:
//
//	len(mockedStorage.FetchLatestCalls())
func (mock *StorageMock) FetchLatestCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}
	mock.lockFetchLatest.RLock()
	calls = mock.calls.FetchLatest
	mock.lockFetchLatest.RUnlock()
	return calls
}

// Query calls QueryFunc.
func (mock *StorageMock) Query(ctx context.Context, q collector.QueryParams, tenants []string) collector.QueryResult {
	if mock.QueryFunc == nil {
		panic("StorageMock.QueryFunc: method is nil but Storage.Query was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Q       collector.QueryParams
		Tenants []string
	}{
		Ctx:     ctx,
		Q:       q,
		Tenants: tenants,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryFunc(ctx, q, tenants)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedStorage.QueryCalls())
func (mock *StorageMock) QueryCalls() []struct {
	Ctx     context.Context
	Q       collector.QueryParams
	Tenants []string
} {
	var calls []struct {
		Ctx     context.Context
		Q       collector.QueryParams
		Tenants []string
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// Query2 calls Query2Func.
func (mock *StorageMock) Query2(ctx context.Context, q collector.QueryParams, tenants []string) collector.QueryResult {
	if mock.Query2Func == nil {
		panic("StorageMock.Query2Func: method is nil but Storage.Query2 was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		Q       collector.QueryParams
		Tenants []string
	}{
		Ctx:     ctx,
		Q:       q,
		Tenants: tenants,
	}
	mock.lockQuery2.Lock()
	mock.calls.Query2 = append(mock.calls.Query2, callInfo)
	mock.lockQuery2.Unlock()
	return mock.Query2Func(ctx, q, tenants)
}

// Query2Calls gets all the calls that were made to Query2.
// Check the length with:
//
//	len(mockedStorage.Query2Calls())
func (mock *StorageMock) Query2Calls() []struct {
	Ctx     context.Context
	Q       collector.QueryParams
	Tenants []string
} {
	var calls []struct {
		Ctx     context.Context
		Q       collector.QueryParams
		Tenants []string
	}
	mock.lockQuery2.RLock()
	calls = mock.calls.Query2
	mock.lockQuery2.RUnlock()
	return calls
}

// QueryDevice calls QueryDeviceFunc.
func (mock *StorageMock) QueryDevice(ctx context.Context, deviceID string, tenants []string) collector.QueryResult {
	if mock.QueryDeviceFunc == nil {
		panic("StorageMock.QueryDeviceFunc: method is nil but Storage.QueryDevice was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Tenants:  tenants,
	}
	mock.lockQueryDevice.Lock()
	mock.calls.QueryDevice = append(mock.calls.QueryDevice, callInfo)
	mock.lockQueryDevice.Unlock()
	return mock.QueryDeviceFunc(ctx, deviceID, tenants)
}

// QueryDeviceCalls gets all the calls that were made to QueryDevice.
// Check the length with:
//
//	len(mockedStorage.QueryDeviceCalls())
func (mock *StorageMock) QueryDeviceCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Tenants  []string
	}
	mock.lockQueryDevice.RLock()
	calls = mock.calls.QueryDevice
	mock.lockQueryDevice.RUnlock()
	return calls
}

// QueryObject calls QueryObjectFunc.
func (mock *StorageMock) QueryObject(ctx context.Context, deviceID string, urn string, tenants []string) collector.QueryResult {
	if mock.QueryObjectFunc == nil {
		panic("StorageMock.QueryObjectFunc: method is nil but Storage.QueryObject was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		DeviceID string
		Urn      string
		Tenants  []string
	}{
		Ctx:      ctx,
		DeviceID: deviceID,
		Urn:      urn,
		Tenants:  tenants,
	}
	mock.lockQueryObject.Lock()
	mock.calls.QueryObject = append(mock.calls.QueryObject, callInfo)
	mock.lockQueryObject.Unlock()
	return mock.QueryObjectFunc(ctx, deviceID, urn, tenants)
}

// QueryObjectCalls gets all the calls that were made to QueryObject.
// Check the length with:
//
//	len(mockedStorage.QueryObjectCalls())
func (mock *StorageMock) QueryObjectCalls() []struct {
	Ctx      context.Context
	DeviceID string
	Urn      string
	Tenants  []string
} {
	var calls []struct {
		Ctx      context.Context
		DeviceID string
		Urn      string
		Tenants  []string
	}
	mock.lockQueryObject.RLock()
	calls = mock.calls.QueryObject
	mock.lockQueryObject.RUnlock()
	return calls
}

// Save calls SaveFunc.
func (mock *StorageMock) Save(ctx context.Context, m collector.Measurement) error {
	if mock.SaveFunc == nil {
		panic("StorageMock.SaveFunc: method is nil but Storage.Save was just called")
	}
	callInfo := struct {
		Ctx context.Context
		M   collector.Measurement
	}{
		Ctx: ctx,
		M:   m,
	}
	mock.lockSave.Lock()
	mock.calls.Save = append(mock.calls.Save, callInfo)
	mock.lockSave.Unlock()
	return mock.SaveFunc(ctx, m)
}

// SaveCalls gets all the calls that were made to Save.
// Check the length with:
//
//	len(mockedStorage.SaveCalls())
func (mock *StorageMock) SaveCalls() []struct {
	Ctx context.Context
	M   collector.Measurement
} {
	var calls []struct {
		Ctx context.Context
		M   collector.Measurement
	}
	mock.lockSave.RLock()
	calls = mock.calls.Save
	mock.lockSave.RUnlock()
	return calls
}

// SaveAll calls SaveManyFunc.
func (mock *StorageMock) SaveAll(ctx context.Context, m []collector.Measurement) error {
	if mock.SaveManyFunc == nil {
		panic("StorageMock.SaveManyFunc: method is nil but Storage.SaveMany was just called")
	}
	callInfo := struct {
		Ctx context.Context
		M   []collector.Measurement
	}{
		Ctx: ctx,
		M:   m,
	}
	mock.lockSaveMany.Lock()
	mock.calls.SaveMany = append(mock.calls.SaveMany, callInfo)
	mock.lockSaveMany.Unlock()
	return mock.SaveManyFunc(ctx, m)
}

// SaveManyCalls gets all the calls that were made to SaveMany.
// Check the length with:
//
//	len(mockedStorage.SaveManyCalls())
func (mock *StorageMock) SaveManyCalls() []struct {
	Ctx context.Context
	M   []collector.Measurement
} {
	var calls []struct {
		Ctx context.Context
		M   []collector.Measurement
	}
	mock.lockSaveMany.RLock()
	calls = mock.calls.SaveMany
	mock.lockSaveMany.RUnlock()
	return calls
}

// SeedMetadata calls SeedMetadataFunc.
func (mock *StorageMock) SeedMetadata(ctx context.Context, metadata []collector.Metadata) error {
	if mock.SeedMetadataFunc == nil {
		panic("StorageMock.SeedMetadataFunc: method is nil but Storage.SeedMetadata was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Metadata []collector.Metadata
	}{
		Ctx:      ctx,
		Metadata: metadata,
	}
	mock.lockSeedMetadata.Lock()
	mock.calls.SeedMetadata = append(mock.calls.SeedMetadata, callInfo)
	mock.lockSeedMetadata.Unlock()
	return mock.SeedMetadataFunc(ctx, metadata)
}

// SeedMetadataCalls gets all the calls that were made to SeedMetadata.
// Check the length with:
//
//	len(mockedStorage.SeedMetadataCalls())
func (mock *StorageMock) SeedMetadataCalls() []struct {
	Ctx      context.Context
	Metadata []collector.Metadata
} {
	var calls []struct {
		Ctx      context.Context
		Metadata []collector.Metadata
	}
	mock.lockSeedMetadata.RLock()
	calls = mock.calls.SeedMetadata
	mock.lockSeedMetadata.RUnlock()
	return calls
}
